# Why software projects in science fail

## Why Software Projects in Science fail
* Brooks: The tar pit. Software is 9x more expensive than the first working version.
* 50 years ago and the tar pit is still the same.

#### Forces that contribute
* Research results, publications, not software is the outcome.
* Complexity of the subject matter is ubiquituous.
* Novelty is a requirement. Maintenance is not encouraged. Reinventing the wheel.
* Projects constrained by funding cycles & PhD careers, not the project itself.
* Continuity - periodic staff turnover is default.
* To some extent it is required that projects are separate between people.
* Technical debt
* Simplicity
* Usefulness: ignoring users. A dangerous symptom for bad software is a publication claiming that the program has been made *"user friendly"*. If no further support for user-friendliness is given, the author has anticipated what a user may want to use the program for. This anticipation is frequently wrong.

#### Degrees of freedom
* languages are not important
* prototype is often OK
* speed is often not an issue

#### Pitfalls
* hacking != software engineering
* non-programmer managers
* lack of courage to clean up and to throw away things
* IP delusion - owning software is very difficult in practice. Comparable to owning a cooking recipe. Our perception of IP derives from Coca Cola. But in most cases owning a recipe is pretty useless. It is the restaurant you build around it that makes it valuable.
* reproducibility - availability of code is not enforced by journals [How science goes wrong, The Economist]
* resilience - taking pride to solve intellectual problems on your own is a trademark of scientists. But it does not contribute to good transparent code.
* lack of humility. If you haven't written enough code. Fortunately easy to fix.
* sustainability - REF Jens Klump
* technical debt
*Quote: Shipping first time code is like going into debt. A little debt speeds development so long as it is paid back promptly with a rewriteÂ… The danger occurs when the debt is not repaid. Every minute spent on not-quite-right code counts as interest on that debt. Entire engineering organizations can be brought to a stand-still under the debt load of an unconsolidated implementation, object-oriented or otherwise.*

**Bottom Line: Software Engineering is a must!**

### What you need to know as a PI
Programming is difficult. It is counter-intuitive. If you are a non-programmer and think you understand programming, chances are you don't. Learn programming or believe what programmers tell you and get out of the way.

**I want to help! What PI can do.**
[Where to put it? Perhaps separate section from PI perspective, talk woth PI]

* set clear goal.
* help with specification.
* learn how to run tests.
* help to design acceptance test, user stories, use cases.
* help to get 'my precious' feeling for the developer.
